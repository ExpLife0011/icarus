/*
Copyright (C) 2013  George Nicolaou <george[at]preaver.[dot]com>
Copyright (C) 2013  Glafkos Charalambous <glafkos[at]gmail.[dot]com>

This file is part of Exploitation Toolkit Icarus (ETI) Library.

Exploitation Toolkit Icarus (ETI) Library is free software: you can redistribute 
it and/or modify it under the terms of the GNU General Public License as 
published by the Free Software Foundation, either version 3 of the License, 
or (at your option) any later version.

Exploitation Toolkit Icarus (ETI) Library is distributed in the hope that it 
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Exploitation Toolkit Icarus (ETI) Library.  
If not, see <http://www.gnu.org/licenses/>.
*/

#include "ExploitabilityAnalysis.h"
#include "StackBufferOverflow.h"

ExploitabilityAnalysis::ExploitabilityAnalysis(void)
{
}


ExploitabilityAnalysis::~ExploitabilityAnalysis(void)
{
}


void ExploitabilityAnalysis::enable_vulnerability_modules( 
	VULNERABILITY_TYPE dwModules )
{
	this->vlpobjEnabledVulnerabilities.clear();
	IVulnerability::get_platform_vulnerabilities( 
		&this->vlpobjEnabledVulnerabilities, dwModules );
}

BOOL ExploitabilityAnalysis::run_vulnerability_classification( 
	IDebugger * lpcDebugger, vector<IVulnerability *> * lpvFoundVulnerabilities )
{
	IVulnerability * lpVulnerabilityModule;

	if( this->vlpobjEnabledVulnerabilities.size() == 0 ) return FALSE;

	dprintflvl( 4, 
		"Running vulnerability classification against %d vulnerability modules", 
		this->vlpobjEnabledVulnerabilities.size() );

	for( int i = 0; i < (int)this->vlpobjEnabledVulnerabilities.size(); i++ ) {
		lpVulnerabilityModule = this->vlpobjEnabledVulnerabilities[i];

		dprintflvl( 4, "Running module: %s", 
			lpVulnerabilityModule->get_vulnerability_name() );

		if( lpVulnerabilityModule->check_for_vulnerability( lpcDebugger ) ) {
			dprintflvl( 4, "Program is vulnerable with: %s", 
				lpVulnerabilityModule->get_vulnerability_name() );
			lpvFoundVulnerabilities->push_back( lpVulnerabilityModule );
			this->vlpobjVulnerabilitiesFound.push_back( lpVulnerabilityModule );
		}
	}

	if( lpvFoundVulnerabilities->size() == 0 ) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

BOOL ExploitabilityAnalysis::run_exploitability_analysis( 
	IDebugger * lpobjDebugger, IVulnerability * lpobjVulnerability )
{
	return lpobjVulnerability->run_vulnerability_analysis( lpobjDebugger );
}

BOOL ExploitabilityAnalysis::run_skeleton_implementation( 
	IDebugger * lpobjDebugger, IVulnerability * lpobjVulnerability )
{
	return lpobjVulnerability->run_skeleton_implementation( lpobjDebugger );
}

BOOL ExploitabilityAnalysis::run_implementation_analysis( 
	IDebugger * lpobjDebugger, IVulnerability * lpobjVulnerability )
{
	return FALSE;
}